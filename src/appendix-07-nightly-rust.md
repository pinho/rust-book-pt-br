<!-- # Appendix G - How Rust is Made and “Nightly Rust” -->
# Apêndice G - Como é feito o Rust e o "Rust Nightly"

This appendix is about how Rust is made and how that affects you as a Rust
developer. We mentioned that the output in this book was generated by stable
Rust 1.21.0, but any examples that compile should continue to compile in any
stable version of Rust greater than that. This section is to explain how we
ensure this is true!

Este apêndice é sobre como o Rust é feito e como isso afeta você como um
desenvolvedor Rust. Mencionamos que a saída deste livro foi gerada pelo Rust
estável (*Stable*) na versão 1.21.0, mas todos os exemplos que compilam devem
continuar sendo compilados em qualquer versão estável do Rust mais recente.
Esta seção explica como garantimos que isso seja verdade!

<!-- ### Stability Without Stagnation -->
### Estabilidade sem estagnação

As a language, Rust cares a *lot* about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can’t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.

Como linguagem, o Rust se preopcupa muito com a estabilidade do seu código.
Queremos que o Rust seja uma base sólida sobre a qual você possa construir,
e se as coisas estivessem mudando constantemente, isso seria impossível. Ao
mesmo tempo, se não pudermos experimentar novos recursos, poderemos descobrir
falhas importantes somente após o lançamento, quando não podemos mais mudar as
coisas.

Our solution to this problem is what we call “stability without stagnation”,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.

Nossa solução para esse problema é o que chamamos de "estabilidade sem
estagnação", e somos guiados pelo seguinte princípio: você nunca deve ter medo
de atualizar para uma nova versão do Rust. Cada atualização deve ser indolor,
mas também deve trazer novos recursos, menos bugs e tempos de compilação mais
rápidos.

<!-- ### Choo, Choo! Release Channels and Riding the Trains -->
### Tchu, Tchu! Canais de _Release_ e Passeios de Trem

Rust development operates on a *train schedule*. That is, all development is
done on the `master` branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three *release channels* for Rust:

O desenvolvimento do Rust opera em um "*train scheduler*" (Horário de trem).
Isto é, todo o desenvolvimento é feito na _branch_ `master` do repositório do
Rust. As versões seguem um modelo de trem de liberação de 
software (_train model_) que têm sido usado pela Cisco IOS e outros projetos de software. Existem três canais de _release_ para o Rust.

<!-- 
* Nightly
* Beta
* Stable
-->

* Nightly
* Beta
* Stable (Estável)

Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.

A maioria dos desenvolvedores Rust usa principalmente o canal estável
(_Stable_), mas aqueles que desejam usar novos recursos experimentais
podem usar o _Nightly_ ou o _Beta_.

Here’s an example of how the development and release process works: let’s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the `master`
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:

Aqui está um exemplo de como o processo de desenvolvimento e lançamento
(_release_) funciona: vamos supor que a equipe do Rust esteja trabalhando no
lançamento do Rust 1.5. Esse lançamento ocorreu em dezembro de 2015, mas nos
fornecerá números de versão realistas. Um novo recurso foi adicionado ao Rust:
um novo commit é feito na _branch_ `master`.
Todas as noites, uma nova versão _Nightly_ do Rust é produzida. Todo dia é um
dia de lançamento e esses lançamentos são criados automaticamente por nossa
infraestrutura de lançamento. Assim, com o passar do tempo, nossos lançamentos
ficam assim, uma vez por noite:

```text
nightly: * - - * - - *
```

Every six weeks, it’s time to prepare a new release! The `beta` branch of the
Rust repository branches off from the `master` branch used by nightly. Now,
there are two releases:

A cada seis semanas, chega a hora de preparar uma nova _release_!
A _branch_ `beta` do repositório do Rust é ramificada a partir da _branch_
`master` usada pelo _Nightly_. Agora existem duas _releases_.

```text
nightly: * - - * - - *
                     |
beta:                *
```

Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there’s still a nightly release every night:

A maioria dos usuários do Rust não usa ativamente as versões beta, mas faz
testes com versões beta no sistema de IC (integração contínua) para ajudar o
Rust a descobrir possíveis regressões. Enquanto isso, ainda há uma _release_
todas as noites:

```text
nightly: * - - * - - * - - * - - *
                     |
beta:                *
```

Let’s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to `master`, so that nightly is fixed, and then the fix is backported to the
`beta` branch, and a new release of beta is produced:

Agora digamos que uma regressão seja encontrada. Ainda bem que tivemos algum
tempo para testar a versão beta antes da regressão se tornar uma versão estável!
A correção é aplicada à _branch_ `master`, de modo que todas as noites é
corrigida e, em seguida, a correção é portada para a _branch_ `beta`, e uma nova
versão beta é produzida:

```text
nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
```

Six weeks after the first beta was created, it’s time for a stable release! The
`stable` branch is produced from the `beta` branch:

Seis semanas depois da criação da primeira versão beta, é hora de uma versão
estável! A _branch_ `stable` é produzida a partir da _branch_` beta`:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
```

Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the *next* version of Rust, 1.6.
So after `stable` branches off of `beta`, the next version of `beta` branches
off of `nightly` again:

Viva! Rust 1.5 está feito! No entanto, esquecemos uma coisa: como as seis
semanas se passaram, também precisamos de uma nova versão beta da *próxima*
versão do Rust, 1.6.
Então, depois que a _branch_ `stable` é criada a partir da `beta`,
a próxima versão da `beta` é criada a partir da `nightly` novamente:

```text
nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
```

This is called the “train model” because every six weeks, a release “leaves the
station”, but still has to take a journey through the beta channel before it
arrives as a stable release.

Isso é chamado de "_train model_" (modelo de trem) porque a cada seis semanas,
uma _release_ "sai da estação", mas ainda precisa percorrer o canal beta antes
de chegar como uma _release_ estável.

Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it’s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there’s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.

O Rust é lançando a cada seis semanas, como um relógio.
Se você souber a data de um lançamento do Rust, poderá saber a data do próximo:
seis semanas depois. Um aspecto interessante de ter lançamentos agendados a cada
seis semanas é que o próximo trem estará chegando em breve. Se um recurso falhar
em uma versão específica, não há necessidade de se preocupar: outra está acontecendo em pouco tempo! Isso ajuda a reduzir a pressão para ocultar recursos
possivelmente "não polidos" perto do prazo de lançamento.

Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it’s easy to upgrade to: if a beta release doesn’t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
`rustc` is still a piece of software, and bugs do exist.

Graças a esse processo, você sempre pode verificar a próxima versão do Rust e
verificar por si mesmo que é fácil fazer uma atualização para a mesma: se uma
versão beta não funcionar conforme o esperado, você pode reportar à equipe e ter
isso corrigido antes do próximo lançamento estável!
A quebra de uma versão beta é relativamente rara, mas o `rustc` ainda é um
software, e bugs existem.

<!-- ### Unstable Features -->
### Recursos instáveis

There’s one more catch with this release model: unstable features. Rust uses a
technique called “feature flags” to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
`master`, and therefore, in nightly, but behind a *feature flag*. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.

Há mais um problema neste modelo de lançamento: recursos instáveis.
O Rust usa uma técnica chamada "sinalizadores de recursos" para determinar quais
recursos estão ativados em uma determinada _release_. Se um novo recurso estiver
em desenvolvimento ativo, ele pousará na _branch_ `master` e, logo, no
_Nightly_, mas atrás de um sinalizador de recurso.
Se você, como usuário, deseja experimentar o recurso de trabalho em andamento, pode, mas deve estar usando uma versão _Nightly_ do Rust e anotar seu
código-fonte com o sinalizador apropriado para ativar.

If you’re using a beta or stable release of Rust, you can’t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won’t break. Stability without stagnation.

Se você estiver usando uma versçao beta ou estável do Rust, você não pode usar
qualquer sinalizador de recurso. Essa é a chave que nos permite usar de forma
prática os novos recursos antes de declará-los estáveis para sempre. Aqueles que
desejam optar pelo que há de mais moderno podem fazê-lo, e aqueles que desejam
uma experiência sólida podem se manter estáveis sabendo que seu código não será
quebrado. Estabilidade sem estagnação.

This book only contains information about stable features, as in-progress
features are still changing, and surely they’ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.

Este livro contém informações apenas sobre recursos estáveis, pois os recursos
em desenvolvimento ainda estão sendo alterados e certamente serão diferentes
entre quando este livro foi escrito e quando eles forem ativados em compilações estáveis.
Você pode encontrar documentação on-line para recursos do exclusivos do
_Nightly_ (_nightly-only_).

<!-- ### Rustup and the Role of Rust Nightly -->
### O Rustup e o papel do _Rust Nightly_

Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you’ll have stable Rust installed. To
install nightly, for example:

O Rustup facilita a troca entre os diferentes canais de _release_ do Rust,
global ou por projeto. Para instalar o _Rust Nightly_, por exemplo:

```text
$ rustup install nightly
```

You can see all of the *toolchains* (releases of Rust and associated
components) you have installed with `rustup` as well. Here’s an example on one
of your authors’ computers:

Você pode ver todos os _toolchains_ (versões do Rust e componentes associados)
instalados com o `rustup` também.
Veja um exemplo nos computadores de seus autores:

```powershell
> rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
```

As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use `rustup override` in that project’s directory to set the
nightly toolchain as the one `rustup` should use when you’re in that directory:

Como pode ver, o _toolchain_ estável (_Stable_) é o padrão. A maioria dos
usuários do Rust usa o estável na maioria das vezes. Você pode querer usar o
estável na mioria das vezes, mas usará o _Nightly_ em um projeto específico
por se preocupar com um recurso de ponta.
Para fazer isso, você pode usar `rustup override` no diretório desse projeto
para definir que o _toolchain_ do _Nightly_ deve ser usado quando o `rustup` for
usado nesse diretório.

```text
$ cd ~/projects/needs-nightly
$ rustup override add nightly
```

Now, every time you call `rustc` or `cargo` inside of
*~/projects/needs-nightly*, `rustup` will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!

Agora, toda que chamar `rustc` ou `cargo` dentro de `~/projects/needs-nightly`,
o `rustup` irá garantir que você esteja usando o _Rust Nightly_ ao invés do
padrão _Rust Stable_. Isso é útil quando você tem muitos projetos em Rust.

### The RFC Process and Teams

So how do you learn about these new features? Rust’s development model follows
a *Request For Comments (RFC) process*. If you’d like an improvement in Rust,
you can write up a proposal, called an RFC.

Então, como você aprende sobre esses novos recursos? O modelo de desenvolvimento
da Rust segue um processo de solicitação de comentários (RFC). Se você deseja
uma melhoria no Rust, pode escrever uma proposta, chamada RFC.

Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There’s
a full list of the teams [on Rust’s
website](https://www.rust-lang.org/en-US/team.html), which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there’s consensus to accept or reject the feature.

Qualquer um pode escrever RFCs para melhorar o Rust, e as propostas são
revisadas e discutidas pela equipe do Rust, que é composta por muitas subequipes
de tópicos. Há uma lista completa das equipes
[no site do Rust](https://www.rust-lang.org/en-US/team.html),
que inclui equipes para cada área do projeto: design de linguagem, implementação
do compilador, infraestrutura, documentação e muito mais. A equipe apropriada
lê a proposta e os comentários, escreve alguns comentários próprios e, eventualmente, há um consenso para aceitar ou rejeitar o recurso.

If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the `master` branch behind a feature gate, as we discussed
in the “Unstable Features” section.

Se o recurso for aceito, uma _Issue_ será aberta no repositório do Rust e alguém
poderá implementá-lo. A pessoa que a implementa pode muito bem não ser a pessoa
que propôs o recurso em primeiro lugar! Quando a implementação está pronta, ela
chega à _branch_ `master` atrás de um sinalizador de recurso, conforme
discutimos na seção "Recursos instáveis".

After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it’s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.

Depois de algum tempo, assim que os desenvolvedores do Rust que usam versões
_Nightly_ puderem experimentar o novo recurso, os membros da equipe discutirão o
recurso, como ele funciona no _Nightly_ e decidirão se ele deve se tornar parte
do Rust estável ou não. Se a decisão for sim, o portão do recurso será removido
e o recurso agora será considerado estável! Ele entra no próximo trem para uma
nova versão estável do Rust.
